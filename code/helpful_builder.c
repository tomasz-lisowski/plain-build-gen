#include <windows.h>
#include <stdio.h>
#include <inttypes.h>
#include <stdbool.h>

#define nullptr 0

typedef struct
{
    char *content;
    uint64_t size;
} config_t;

typedef struct
{
    uint64_t i_start;
    uint64_t i_end;
    uint64_t len;
} config_substr_t;

typedef struct
{
    config_substr_t *output_path;

    config_substr_t *source_files;
    uint64_t num_source_files;
    config_substr_t *include_paths;
    uint64_t num_include_paths;
    config_substr_t *compiler_flags;
} config_parsed_t;

static config_t *cfg_raw;
// static const char *build_script_prologue = "REM Autogenerated by Helpful_Builder\n";

config_substr_t cfg_next_line(const uint64_t i_start)
{
    config_substr_t line = {.i_start = i_start,
                            .i_end = cfg_raw->size - 1,
                            .len = 0};
    for (uint64_t newline_i = i_start; newline_i < cfg_raw->size; newline_i++)
    {
        if (cfg_raw->content[newline_i] == 13)
        {
            line.i_end = newline_i % cfg_raw->size;
            break;
        }
    }
    line.len = line.i_end - line.i_start;
    return line;
}

bool cfg_substr_matches(const config_substr_t substr,
                        const char *str,
                        const uint32_t str_len)
{
    if (substr.len < str_len)
    {
        return false;
    }
    size_t i_str = 0;
    for (uint64_t i = substr.i_start; i < substr.i_end; i++)
    {
        if (cfg_raw->content[i] != str[i_str])
        {
            return false;
        }
        else
        {
            if (i_str == str_len - 1)
            {
                return true;
            }
            i_str++;
        }
    }
    return false;
}

void cfg_print_substr(const config_substr_t substr)
{
    for (uint64_t i = substr.i_start; i < substr.i_end; i++)
    {
        printf("%c", cfg_raw->content[i]);
    }
    printf("\n");
}

// Returns start index of the first line after block
uint64_t cfg_parse_block(config_substr_t **block,
                         uint64_t *block_el_count,
                         const uint64_t i_start)
{
    uint64_t el_i = 0;
    config_substr_t current_line = cfg_next_line(i_start);
    bool skipLine;
    bool endOfBlock;
    do
    {
        // On first iteration, skip over block start "[...]"
        current_line = cfg_next_line(current_line.i_end + 2);
        skipLine = current_line.len == 0 || cfg_substr_matches(current_line, "//", 2);
        endOfBlock = cfg_substr_matches(current_line, "[end]", 5);

        if (!skipLine && !endOfBlock)
        {
            *block = realloc(*block, (el_i + 1) * sizeof(config_substr_t));
            memcpy(*block + el_i, &current_line, sizeof(config_substr_t));
            el_i++;
        }
    } while (!endOfBlock);

    *block_el_count = el_i; // Report back how many elements were actually read
    return current_line.i_end + 2;
}

void cfg_parse_all_blocks(config_parsed_t **cfg_parsed)
{
    for (uint64_t i = 0; i < cfg_raw->size;)
    {
        config_substr_t current_line = cfg_next_line(i);
        i = current_line.i_end + 2; /* Skip CRLF */

        if (current_line.len == 0 ||
            cfg_substr_matches(current_line, "//", 2) ||
            cfg_substr_matches(current_line, "[end]", 5))
        {
            continue;
        }
        else if (cfg_substr_matches(current_line, "[output_path]", 13))
        {
            uint64_t num_output_paths;
            i = cfg_parse_block(&(*cfg_parsed)->output_path,
                                &num_output_paths,
                                current_line.i_start);
            if (num_output_paths != 1)
            {
                printf("Specify exactly one output path.\n");
                exit(1);
            }
            continue;
        }
        else if (cfg_substr_matches(current_line, "[source]", 8))
        {
            i = cfg_parse_block(&(*cfg_parsed)->source_files,
                                &(*cfg_parsed)->num_source_files,
                                current_line.i_start);
            continue;
        }
        else if (cfg_substr_matches(current_line, "[include]", 9))
        {
            i = cfg_parse_block(&(*cfg_parsed)->include_paths,
                                &(*cfg_parsed)->num_include_paths,
                                current_line.i_start);
            continue;
        }
    }
}

config_parsed_t *cfg_parse()
{
    config_parsed_t *cfg_parsed = malloc(sizeof(config_parsed_t));
    memset(cfg_parsed, '\0', sizeof(config_parsed_t));
    cfg_parse_all_blocks(&cfg_parsed);

    return cfg_parsed;
}

uint64_t
cfg_num_chars_in_block(config_substr_t **block,
                       uint64_t *block_el_count)
{
    uint64_t num_chars = 0;
    for (uint64_t src_i = 0; src_i < *block_el_count; ++src_i)
    {
        num_chars += (*block)[src_i].len;
    }
    return num_chars;
}

// Returns buffer offset of first empty empty spot in buffer after appending block
uint64_t
cfg_append_block_to_buffer(char **buffer,
                           uint64_t buffer_start_offset,
                           config_substr_t **block,
                           uint64_t *block_el_count)
{
    uint64_t buffer_offset = buffer_start_offset;
    for (uint64_t el_i = 0; el_i < *block_el_count; ++el_i)
    {
        memcpy((*buffer) + buffer_offset, cfg_raw->content + (*block)[el_i].i_start, (*block)[el_i].len);
        buffer_offset += (*block)->len + 1;
        (*buffer)[buffer_offset - 1] = ' ';
    }
    return buffer_offset;
}

char *cfg_substr_to_string(config_substr_t **substr)
{
    char *substr_string = malloc((*substr)->len);
    memcpy(substr_string, &cfg_raw->content[(*substr)->i_start], (*substr)->len);
    substr_string[(*substr)->len] = '\0';
    return substr_string;
}

void createBuildScript(config_parsed_t **cfg_parsed,
                       char *filePath)
{
    HANDLE build_file_handle = CreateFileA(
        filePath,
        GENERIC_WRITE,
        0,
        0,
        CREATE_ALWAYS,
        FILE_FLAG_SEQUENTIAL_SCAN,
        0);
    if (build_file_handle == INVALID_HANDLE_VALUE)
    {
        printf("Failed to create the build script on disk.\n");
        exit(1);
    }

    uint64_t sources_num_chars = cfg_num_chars_in_block(&(*cfg_parsed)->source_files,
                                                        &(*cfg_parsed)->num_source_files);
    char *build_script_content = malloc(sources_num_chars + (*cfg_parsed)->num_source_files);
    uint64_t build_script_content_top = cfg_append_block_to_buffer(&build_script_content,
                                                                   0,
                                                                   &(*cfg_parsed)->source_files,
                                                                   &(*cfg_parsed)->num_source_files);
    // TODO: Append all other block to the buffer. Consider storing block elements as strings and not config_substr_t
    DWORD num_bytes_written;
    BOOL success_writing_file = WriteFile(
        build_file_handle,
        build_script_content,
        build_script_content_top,
        &num_bytes_written,
        0);
    if (num_bytes_written != build_script_content_top)
    {
        printf("Failed to write build script to disk.\n");
        exit(1);
    }
    return;
}

int main(int argc, char *argv[argc + 1])
{
    if (argc != 2)
    {
        printf("Please specify the path to a config file.\n");
        return EXIT_FAILURE;
    }

    HANDLE cfg_handle = CreateFileA(
        argv[1],
        GENERIC_READ,
        0,
        0,
        OPEN_EXISTING,
        FILE_FLAG_SEQUENTIAL_SCAN,
        0);
    if (cfg_handle == INVALID_HANDLE_VALUE ||
        GetLastError() == ERROR_FILE_NOT_FOUND)
    {
        printf("Config file not found.\n");
        return EXIT_FAILURE;
    }

    LARGE_INTEGER cfg_size;
    BOOL success = GetFileSizeEx(
        cfg_handle,
        &cfg_size);

    if (!success)
    {
        printf("Failed to get the config file size.\n");
        return EXIT_FAILURE;
    }

    uint64_t cfg_buffer_size = cfg_size.QuadPart + 1;
    char *cfg_buffer = malloc(cfg_buffer_size);
    DWORD bytes_read = 0;
    success = ReadFile(
        cfg_handle,
        (void *)cfg_buffer,
        cfg_buffer_size - 1,
        &bytes_read,
        0);
    if (!success)
    {
        printf("Failed to read the config file.\n");
        return EXIT_FAILURE;
    }
    cfg_buffer[cfg_buffer_size - 1] = '\0';

    cfg_raw = malloc(sizeof(config_t));
    cfg_raw->content = cfg_buffer;
    cfg_raw->size = cfg_buffer_size;
    config_parsed_t *cfg_parsed = cfg_parse();

    char *build_script_path = cfg_substr_to_string(&cfg_parsed->output_path);
    createBuildScript(&cfg_parsed, build_script_path);

    // No need to explicitly free malloc'd memory before quitting program
    return EXIT_SUCCESS;
}
